/*!    \file   process.c    \brief  system call related to process handling*/#include <ace.h>#include <string.h>#include <kernel/debug.h>#include <kernel/pm/task.h>#include <kernel/pm/thread.h>#include <kernel/system_call_handler.h>/*! terminate a processThe value of status may be 0, EXIT_SUCCESS, EXIT_FAILURE, [CX]   or any other value, though only the least significant 8 bits (that is, status & 0377) shall be available to a waiting parent process. */UINT32 syscall_exit(SYSTEM_CALL_ARGS_PTR sys_call_args, UINT32 *retval){	ExitThread();	/*Not reached*/	return -1;}/*! create a new process*/UINT32 syscall_fork(SYSTEM_CALL_ARGS_PTR sys_call_args, UINT32 *retval){	KTRACE("%p %p %p %p\n", sys_call_args->args[0], sys_call_args->args[1], sys_call_args->args[2], sys_call_args->args[3]);
	* retval = -1;
	return 0;}/*! create new process; share virtual memory*/UINT32 syscall_vfork(SYSTEM_CALL_ARGS_PTR sys_call_args, UINT32 *retval){	KTRACE("%p %p %p %p\n", sys_call_args->args[0], sys_call_args->args[1], sys_call_args->args[2], sys_call_args->args[3]);
	* retval = -1;
	return 0;
}/*! wait for a child process to stop or terminate	pid_t wait(int *stat_loc);	pid_t waitpid(pid_t pid, int *stat_loc, int options);*/UINT32 syscall_waitpid(SYSTEM_CALL_ARGS_PTR sys_call_args, UINT32 *retval){	KTRACE("%p %p %p %p\n", sys_call_args->args[0], sys_call_args->args[1], sys_call_args->args[2], sys_call_args->args[3]);
	* retval = -1;
	return 0;}/*! wait for a child process to stop or terminate	 pid_t wait4(pid_t pid, int *status, int options, struct rusage *rusage);*/UINT32 syscall_wait4(SYSTEM_CALL_ARGS_PTR sys_call_args, UINT32 *retval){	KTRACE("%p %p %p %p\n", sys_call_args->args[0], sys_call_args->args[1], sys_call_args->args[2], sys_call_args->args[3]);
	* retval = -1;
	return 0;}/*! execute a fileint execl(const char *path, const char *arg0, ... );int execv(const char *path, char *const argv[]);int execle(const char *path, const char *arg0, ... ,       (char *)0, char *const envp[]);int execve(const char *path, char *const argv[], char *const envp[]);int execlp(const char *file, const char *arg0, ... );int execvp(const char *file, char *const argv[]);*/UINT32 syscall_execve(SYSTEM_CALL_ARGS_PTR sys_call_args, UINT32 *retval){	KTRACE("%p %p %p %p\n", sys_call_args->args[0], sys_call_args->args[1], sys_call_args->args[2], sys_call_args->args[3]);
	* retval = -1;
	return 0;}	/*! suspend the thread until a signal is received*/UINT32 syscall_pause(SYSTEM_CALL_ARGS_PTR sys_call_args, UINT32 *retval){	KTRACE("%p %p %p %p\n", sys_call_args->args[0], sys_call_args->args[1], sys_call_args->args[2], sys_call_args->args[3]);
	* retval = -1;
	return 0;}	/*! change the nice value of a procesint nice(int incr); */UINT32 syscall_nice(SYSTEM_CALL_ARGS_PTR sys_call_args, UINT32 *retval){	KTRACE("%p %p %p %p\n", sys_call_args->args[0], sys_call_args->args[1], sys_call_args->args[2], sys_call_args->args[3]);
	* retval = -1;
	return 0;}/*! send a signal to a process or a group of processesint kill(pid_t pid, int sig);*/UINT32 syscall_kill(SYSTEM_CALL_ARGS_PTR sys_call_args, UINT32 *retval){	KTRACE("%p %p %p %p\n", sys_call_args->args[0], sys_call_args->args[1], sys_call_args->args[2], sys_call_args->args[3]);
	* retval = -1;
	return 0;}	/*! get command line of the current task*/UINT32 syscall_getcmdline(SYSTEM_CALL_ARGS_PTR sys_call_args, UINT32 *retval){	KTRACE("%p %p %p %p\n", sys_call_args->args[0], sys_call_args->args[1], sys_call_args->args[2], sys_call_args->args[3]);	TASK_PTR task;	* retval = NULL;	task = GetCurrentTask();	assert( task != NULL );	/*if we have buffered command line in kernel memory, allocate user va and copy kernel command line to it */	if( task->kva_command_line )	{		ERROR_CODE ret;		ret = AllocateVirtualMemory( GetCurrentVirtualMap(), (VADDR*)&task->uva_command_line, 0, PAGE_ALIGN_UP( strlen(task->kva_command_line)+1 ), PROT_WRITE | PROT_READ, 0, NULL  );		if ( ret != ERROR_SUCCESS )		{			KTRACE("%s\n", ERROR_CODE_AS_STRING(ret) );			return 1;		}		strcpy( task->uva_command_line, task->kva_command_line );				/*free kernel memory*/		kfree(task->kva_command_line);		task->kva_command_line = NULL;	}		* retval  = (UINT32)task->uva_command_line;		return 0;}	/*! get environment*/UINT32 syscall_getenvironment(SYSTEM_CALL_ARGS_PTR sys_call_args, UINT32 *retval){	TASK_PTR task;	KTRACE("%p %p %p %p\n", sys_call_args->args[0], sys_call_args->args[1], sys_call_args->args[2], sys_call_args->args[3]);		* retval = NULL;	task = GetCurrentTask();	assert( task != NULL );	/*if we have buffered environment in kernel memory, allocate user va and copy kernel command line to it */	if( task->kva_environment )	{		ERROR_CODE ret;		ret = AllocateVirtualMemory( GetCurrentVirtualMap(), (VADDR*)&task->uva_environment, 0, PAGE_ALIGN_UP( strlen(task->kva_environment)+1 ), PROT_WRITE | PROT_READ, 0, NULL  );		if ( ret != ERROR_SUCCESS )		{			KTRACE("%s\n", ERROR_CODE_AS_STRING(ret) );			return 1;		}		strcpy( task->uva_environment, task->kva_environment );				/*free kernel memory*/		kfree(task->kva_environment);		task->kva_environment = NULL;	}		* retval  = (UINT32)task->uva_environment;		return 0;}	