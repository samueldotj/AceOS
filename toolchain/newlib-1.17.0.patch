diff -rupN newlib-1.17.0/config.sub ../newlib-1.17.0/config.sub
--- newlib-1.17.0/config.sub	2008-12-18 08:56:46.000000000 +0530
+++ ../newlib-1.17.0/config.sub	2009-05-15 20:02:26.359375000 +0530
@@ -1276,7 +1276,7 @@ case $os in
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
 	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
 	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
-	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops*)
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -aceos*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
diff -rupN newlib-1.17.0/newlib/configure.host ../newlib-1.17.0/newlib/configure.host
--- newlib-1.17.0/newlib/configure.host	2008-12-18 04:39:09.000000000 +0530
+++ ../newlib-1.17.0/newlib/configure.host	2009-05-15 20:02:26.375000000 +0530
@@ -398,6 +398,9 @@ case "${host}" in
   h8500-*-elf*)
 	sys_dir=h8500hms
 	;;
+  i[34567]86-*-aceos*)
+	sys_dir=aceos
+	;;
   i[34567]86-*-rdos*)
 	sys_dir=rdos
 	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
diff -rupN newlib-1.17.0/newlib/libc/include/sys/wait.h ../newlib-1.17.0/newlib/libc/include/sys/wait.h
--- newlib-1.17.0/newlib/libc/include/sys/wait.h	2000-02-18 01:09:46.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/include/sys/wait.h	2009-05-15 20:02:26.375000000 +0530
@@ -33,6 +33,25 @@ pid_t waitpid (pid_t, int *, int);
    provided in newlib for some compilers.  */
 pid_t _wait (int *);
 
+union wait
+  {
+    int w_status;
+    struct
+      {
+        unsigned int __w_termsig:7; /* Terminating signal.  */
+        unsigned int __w_coredump:1; /* Set if dumped core.  */
+        unsigned int __w_retcode:8; /* Return code if exited normally.  */
+        unsigned int:16;
+      } __wait_terminated;
+    struct
+      {
+        unsigned int __w_stopval:8; /* W_STOPPED if stopped.  */
+        unsigned int __w_stopsig:8; /* Stopping signal.  */
+        unsigned int:16;
+      } __wait_stopped;
+  };
+
+
 #ifdef __cplusplus
 };
 #endif
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/Makefile.am ../newlib-1.17.0/newlib/libc/sys/aceos/Makefile.am
--- newlib-1.17.0/newlib/libc/sys/aceos/Makefile.am	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/Makefile.am	2009-05-23 08:02:16.656250000 +0530
@@ -0,0 +1,23 @@
+AUTOMAKE_OPTIONS = cygnus
+INCLUDES = $(NEWLIB_CFLAGS) $(CROSS_CFLAGS) $(TARGET_CFLAGS)
+AM_CCASFLAGS = $(INCLUDES)
+
+noinst_LIBRARIES = lib.a
+
+extra_objs = $(lpfx)syscalls.o $(lpfx)termios.o  $(lpfx)uname.o $(lpfx)sysconf.o $(lpfx)dirent.o $(lpfx)file.o $(lpfx)proc.o $(lpfx)clock.o $(lpfx)mem.o $(lpfx)ioctl.o $(lpfx)tty.o
+
+lib_a_SOURCES =
+lib_a_LIBADD = $(extra_objs)
+EXTRA_lib_a_SOURCES = syscalls.c crt0.c termios.c uname.c sysconf.c dirent.c file.c proc.c clock.c mem.c ioctl.c tty.c statfs.c mount.c
+lib_a_DEPENDENCIES = $(extra_objs)
+lib_a_CCASFLAGS = $(AM_CCASFLAGS)
+lib_a_CFLAGS = $(AM_CFLAGS)
+
+nobase_include_HEADERS = sys/ioctl.h sys/_types.h sys/types.h sys/unistd.h sys/utsname.h sys/dirent.h sys/stat.h sys/poll.h sys/statfs.h sys/mount.h
+
+include_HEADERS = sys/termios.h
+
+all: crt0.o
+
+ACLOCAL_AMFLAGS = -I ../../..
+CONFIG_STATUS_DEPENDENCIES = $(newlib_basedir)/configure.host
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/clock.c ../newlib-1.17.0/newlib/libc/sys/aceos/clock.c
--- newlib-1.17.0/newlib/libc/sys/aceos/clock.c	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/clock.c	2009-05-18 19:14:45.765625000 +0530
@@ -0,0 +1,27 @@
+#include <syscall.h>
+#include <sys/times.h>
+#include <sys/time.h>
+
+/*! get process and waited-for child process times*/
+clock_t times(struct tms *buf)
+{
+	return syscall( SYS_TIMES, (ulong)buf, 0, 0, 0, 0, &errno );
+}
+
+/*! get the date and time*/
+int gettimeofday(struct timeval *p, void *z)
+{
+	return syscall( SYS_GETTIMEOFDAY, (ulong)p, (ulong)z, 0, 0, 0, &errno );
+}
+
+/*! suspend execution for an interval of time*/
+unsigned int sleep(unsigned int t)
+{
+	return syscall( SYS_SLEEP, (ulong)t, 0, 0, 0, 0, &errno );
+}
+
+/*! schedule an alarm signal*/
+unsigned alarm(unsigned seconds)
+{
+	return syscall( SYS_ALARM, (ulong)seconds, 0, 0, 0, 0, &errno );
+}
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/configure.in ../newlib-1.17.0/newlib/libc/sys/aceos/configure.in
--- newlib-1.17.0/newlib/libc/sys/aceos/configure.in	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/configure.in	2009-05-22 21:10:53.296875000 +0530
@@ -0,0 +1,7 @@
+AC_PREREQ(2.59)
+AC_INIT([newlib], [NEWLIB_VERSION])
+AC_CONFIG_SRCDIR([crt0.c])
+AC_CONFIG_AUX_DIR(../../../..)
+NEWLIB_CONFIGURE(../../..)
+AC_CONFIG_FILES([Makefile])
+AC_OUTPUT
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/crt0.c ../newlib-1.17.0/newlib/libc/sys/aceos/crt0.c
--- newlib-1.17.0/newlib/libc/sys/aceos/crt0.c	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/crt0.c	2009-05-24 14:58:38.031250000 +0530
@@ -0,0 +1,77 @@
+#include <stdlib.h>
+
+void main(int argc, char * argv[]);
+void _init_signal();
+void exit();
+char * getcommandline();
+
+void * split_string_to_arg_array(char * string, int * count);
+
+extern char **environ;
+
+void _start()
+{
+	int argc=1;
+	char * * cmd_argv;
+	char * * env_argv;
+	char * cmdline;
+	char * environment;
+	
+	/*get the command line from kernel*/
+	cmdline = getcommandline();
+	cmd_argv = split_string_to_arg_array( cmdline, &argc );
+	
+	environment = getenvironment();
+	environ = split_string_to_arg_array( environment, &argc );
+		
+	_init_signal();
+	main(argc, cmd_argv);
+	exit(0);
+}
+
+void * split_string_to_arg_array(char * string, int * count)
+{
+	int argc=0;
+	char * * argv = NULL;
+	int i=0;
+	/*see how many arguments are there - just count the spaces for now*/
+	while( string && string[i] )
+	{
+		if ( string[i] == ' ' )
+		{
+			argc++;
+			/*skip the spaces*/
+			while( string[i]==' ') i++;
+		}
+		if ( string[i] )
+			i++;
+	}
+	if ( count )
+		*count = argc;
+	
+	/*allocate memory for argv*/
+	argv = malloc( (argc+1) * sizeof(char *) );
+
+	/*create argv from the string*/
+	argc = 1;
+	argv[0] = string;
+	i=0;
+	while( string && string[i] )
+	{
+		if ( string[i] == ' ' )
+		{
+			string[i++] = 0;
+			/*skip the whitespaces*/
+			while( string[i]==' ') i++;
+			argv[argc] = &string[i];
+			argc++;
+		}
+		if ( string[i] )
+			i++;
+	}
+	/*last entry should point to null*/
+	if ( string )
+		argv[argc] = NULL;
+	return argv;
+}
+
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/dirent.c ../newlib-1.17.0/newlib/libc/sys/aceos/dirent.c
--- newlib-1.17.0/newlib/libc/sys/aceos/dirent.c	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/dirent.c	2009-05-22 20:43:35.359375000 +0530
@@ -0,0 +1,48 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/dirent.h>
+#include <syscall.h>
+
+/*opens a directory stream corresponding to the directory named by the dirname argument. The directory stream is positioned at the first entry*/
+DIR *opendir(const char * dirname)
+{
+	return (DIR *)syscall( SYS_OPEN_DIR, (ulong)dirname, 0, 0, 0, 0, &errno );
+}
+
+/*closes the directory stream referred to by the argument dirp */
+int closedir(DIR * dir)
+{
+	return syscall( SYS_CLOSE_DIR, (ulong)dir, 0, 0, 0, 0, &errno );
+}
+
+/*returns a pointer to a structure representing the directory entry at the current position in the directory stream specified by the argument dirp, 
+and positions the directory stream at the next entry. It returns a null pointer upon reaching the end of the directory stream*/
+struct dirent *readdir(DIR * dir)
+{
+	return (DIR *)syscall( SYS_READ_DIR, (ulong)dir, 0, 0, 0, 0, &errno );
+}
+
+int readdir_r(DIR * dir, struct dirent * ent, struct dirent ** entp)
+{
+	return syscall( SYS_READ_DIR_R, (ulong)dir, (ulong)ent, (ulong)entp, 0, 0, &errno );
+}
+
+/*resets the position of the directory stream to which dirp refers to the beginning of the directory. 
+It also causes the directory stream to refer to the current state of the corresponding directory, as a call to opendir() would have done.*/
+void rewinddir(DIR * dir)
+{
+	syscall( SYS_REWIND_DIR, (ulong)dir, 0, 0, 0, 0, &errno );
+}
+
+/*sets the position of the next readdir() operation on the directory stream specified by dirp to the position specified by loc. The value of loc should have been returned from an earlier call to telldir().
+ The new position reverts to the one associated with the directory stream when telldir() was performed.*/
+void seekdir(DIR * dir, long int off)
+{
+	syscall( SYS_SEEK_DIR, (ulong)dir, off, 0, 0, 0, &errno );
+}
+
+/*obtains the current location associated with the directory stream specified by dirp.*/
+long int telldir(DIR * dir)
+{
+	return syscall( SYS_TELL_DIR, (ulong)dir, 0, 0, 0, 0, &errno );
+}
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/file.c ../newlib-1.17.0/newlib/libc/sys/aceos/file.c
--- newlib-1.17.0/newlib/libc/sys/aceos/file.c	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/file.c	2009-05-23 09:24:10.843750000 +0530
@@ -0,0 +1,187 @@
+#include <stdio.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <syscall.h>
+#include <sys/poll.h>
+
+/*It shall establish the connection between a file and a file descriptor. 
+It shall create an open file description that refers to a file and a file descriptor that refers to that open file description. 
+The file descriptor is used by other I/O functions to refer to that file. The path argument points to a pathname naming the file.*/
+int open(const char *name, int flags, ...)
+{
+	return syscall( SYS_OPEN, (ulong)name, flags, 0, 0, 0, &errno );
+}
+
+/*The close() function shall deallocate the file descriptor indicated by fildes. 
+To deallocate means to make the file descriptor available for return by subsequent calls to open() or other functions that allocate file descriptors. 
+All outstanding record locks owned by the process on the file associated with the file descriptor shall be removed (that is, unlocked).*/
+int close(int file)
+{
+	return syscall( SYS_CLOSE, file, 0, 0, 0, 0, &errno );
+}
+
+/*The read() function shall attempt to read nbyte bytes from the file associated with the open file descriptor, fildes, into the buffer pointed to by buf.*/
+int read(int fd, void * buf, size_t nbyte )
+{
+	return syscall( SYS_READ, fd, (ulong)buf, nbyte, 0, 0, &errno );
+}
+
+/*The write() function shall attempt to write nbyte bytes from the buffer pointed to by buf to the file associated with the open file descriptor, fildes.*/
+int write(int fd, const void * buf, size_t nbyte )
+{
+	return syscall( SYS_WRITE, fd, (ulong)buf, nbyte, 0, 0, &errno );
+}
+
+/*get the pathname of the current working directory*/
+char * getcwd(char * name, size_t size)
+{
+	return (char *)syscall( SYS_GETCWD, (ulong)name, size, 0, 0, 0, &errno );
+}
+
+/*change working directory*/
+int chdir(const char *path)
+{
+	return syscall( SYS_CHDIR, (ulong)path, 0, 0, 0, 0, &errno );
+}
+
+/*get file status*/
+int stat(const char *file, struct stat *st)
+{
+	return syscall( SYS_STAT, (ulong)file, (ulong)st, 0, 0, 0, &errno );
+}
+
+/*get file status*/
+int fstat(int file, struct stat *st)
+{
+	return syscall( SYS_FSTAT, file, (ulong)st, 0, 0, 0, &errno );
+}
+
+int lstat(const char * name, struct stat * st)
+{
+	return syscall( SYS_LSTAT, (ulong)name, (ulong)st, 0, 0, 0, &errno );
+}
+
+/*move the read/write file offset*/
+off_t lseek(int fildes, off_t offset, int whence )
+{
+	return syscall( SYS_LSEEK, fildes, offset, whence, 0, 0, &errno );	
+}
+
+/*shall create a new link (directory entry) for the existing file, path1*/
+int link(const char *old, const char *new)
+{
+	return syscall( SYS_LINK, (ulong)old, (ulong)new, 0, 0, 0, &errno );
+}
+
+/*unlink() function shall remove a link to a file. If path names a symbolic link, unlink() shall remove the symbolic link named by path and shall not affect any file or directory named by the contents of the symbolic link. Otherwise, unlink() shall remove the link named by the pathname pointed to by path and shall decrement the link count of the file referenced by the link.*/
+int unlink(const char *name)
+{
+	return syscall( SYS_UNLINK, (ulong)name, 0, 0, 0, 0, &errno );
+}
+
+/*rename a file*/
+int rename(const char *old, const char *new)
+{
+	return syscall( SYS_RENAME, (ulong)old, (ulong)new, 0, 0, 0, &errno );
+}
+
+/*change mode of a file*/
+int chmod(const char * name, mode_t mode)
+{
+	return syscall( SYS_CHMOD, (ulong)name, (ulong)mode, 0, 0, 0, &errno );
+}
+
+/*change mode of a file*/
+int fchmod(int file, mode_t mode)
+{
+	return syscall( SYS_FCHMOD, file, (ulong)mode, 0, 0, 0, &errno );
+}
+
+/*make directory*/
+int mkdir(const char * name, mode_t mode)
+{
+	return syscall( SYS_MKDIR, (ulong)name, (ulong) mode, 0, 0, 0, &errno );
+}
+
+/*remove a directory*/
+int rmdir(const char *path)
+{
+	return syscall( SYS_RMDIR, (ulong)path, 0, 0, 0, 0, &errno );
+}
+
+/* change working directory*/
+int fchdir(int fildes)
+{
+	return syscall( SYS_FCHDIR, fildes, 0, 0, 0, 0, &errno );
+}
+
+/*set and get the file mode creation mask*/
+mode_t umask(mode_t mode)
+{
+	return syscall( SYS_UMASK, (ulong)mode, 0, 0, 0, 0, &errno );
+}
+
+/*! file control*/
+int fcntl(int fildes, int cmd, int arg)
+{
+	return syscall( SYS_FCNTL, fildes, cmd, arg, 0, 0,  &errno );
+}
+
+/*! duplicate an open file descriptor*/
+int dup(int fildes)
+{
+	return syscall( SYS_DUP, fildes, 0, 0, 0, 0, &errno );
+}
+
+/*! duplicate an open file descriptor*/
+int dup2(int fildes, int fildes2)
+{
+	return syscall( SYS_DUP, fildes, fildes2, 0, 0, 0, &errno );
+}
+
+/*!  determine accessibility of a file*/
+int access(const char *path, int amode)
+{
+	return syscall( SYS_ACCESS, (ulong)path, amode, 0, 0, 0, &errno );
+}
+
+/*!create an interprocess channel*/
+int pipe(int fildes[2])
+{
+	return syscall( SYS_PIPE, (ulong)fildes[0], (ulong)fildes[1], 0, 0, 0, &errno );
+}
+
+/*! synchronous I/O multiplexing*/
+int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout)
+{
+	return syscall( SYS_SELECT, (ulong)nfds, (ulong)readfds, (ulong)writefds, (ulong)errorfds, (ulong)timeout, &errno );
+}
+
+/*input/output multiplexing*/
+int poll(struct pollfd * fds, nfds_t nfds, int timeout)
+{
+	return syscall( SYS_POLL, (ulong)fds, (ulong)nfds, (ulong)timeout, 0, 0, &errno );
+}
+
+/*cause all information in memory that updates file systems to be scheduled for writing out to all file systems. The writing, although scheduled, is not necessarily complete upon return from sync()*/
+void sync(void)
+{
+	syscall( SYS_SYNC, 0, 0, 0, 0, 0, &errno );
+}
+
+/* truncate a file to a specified length*/
+int truncate(const char *path, off_t length)
+{
+	return syscall( SYS_TRUNCATE, (ulong)path, (ulong)length, 0, 0, 0, &errno );
+}
+
+int ftruncate(int fildes, off_t length)
+{
+	return syscall( SYS_FTRUNCATE, (ulong)fildes, (ulong)length, 0, 0, 0, &errno );
+}
+
+/*! make a directory, a special file, or a regular file*/
+int mknod(const char *path, mode_t mode, dev_t dev)
+{
+	return syscall( SYS_MKNOD, (ulong)path, (ulong)mode, (ulong)dev, 0, 0, &errno );
+}
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/ioctl.c ../newlib-1.17.0/newlib/libc/sys/aceos/ioctl.c
--- newlib-1.17.0/newlib/libc/sys/aceos/ioctl.c	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/ioctl.c	2009-05-17 11:44:45.968750000 +0530
@@ -0,0 +1,13 @@
+#include <syscall.h>
+#include <stdarg.h>
+int ioctl(int fd, int request, ... )
+{
+    va_list ap;
+    int res;
+
+    va_start(ap,request);
+    res = syscall( SYS_IOCTL, fd, request, (ulong) va_arg(ap,void *), 0, 0, &errno );
+    va_end(ap);
+	
+    return res;
+}
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/mem.c ../newlib-1.17.0/newlib/libc/sys/aceos/mem.c
--- newlib-1.17.0/newlib/libc/sys/aceos/mem.c	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/mem.c	2009-05-17 18:49:00.203125000 +0530
@@ -0,0 +1,10 @@
+#include <syscall.h>
+
+#define PROT_READ					1
+#define PROT_WRITE					2
+#define PROT_EXECUTE				4
+
+void * sbrk(int incr)
+{
+	return (void *) syscall( SYS_ALLOCATE_VIRTUAL_MEMORY, incr, PROT_READ|PROT_WRITE|PROT_EXECUTE, 0, 0, 0, &errno );
+}
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/mount.c ../newlib-1.17.0/newlib/libc/sys/aceos/mount.c
--- newlib-1.17.0/newlib/libc/sys/aceos/mount.c	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/mount.c	2009-05-23 08:01:51.843750000 +0530
@@ -0,0 +1,18 @@
+
+#include <sys/mount.h>
+#include <syscall.h>
+
+int mount (const char * fs, const char * path, unsigned __flags)
+{
+	return (char *)syscall( SYS_MOUNT, (ulong)fs, (ulong)path, 0, 0, 0, &errno );
+}
+
+int umount (const char * path)
+{
+	return (char *)syscall( SYS_UMOUNT, (ulong)path, 0, 0, 0, 0, &errno );
+}
+
+int getmntinfo(struct statfs **mntbufp, int flags)
+{
+	return (char *)syscall( SYS_GETMNTINFO, (ulong)mntbufp, flags, 0, 0, 0, &errno );
+}
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/proc.c ../newlib-1.17.0/newlib/libc/sys/aceos/proc.c
--- newlib-1.17.0/newlib/libc/sys/aceos/proc.c	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/proc.c	2009-05-23 08:09:08.359375000 +0530
@@ -0,0 +1,65 @@
+#include <syscall.h>
+#include <stdio.h>
+#include <errno.h>
+
+/*terminate a process*/
+void _exit(int status)
+{
+	syscall( SYS_EXIT, status, 0, 0, 0, 0, &errno );
+}
+
+/*exec family of functions shall replace the current process image with a new process image.*/
+int execve(const char *path, char * const argv[], char * const envp[] )
+{
+	return syscall( SYS_EXECVE, (ulong)path, (ulong)argv, (ulong)envp, 0, 0, &errno );
+}
+
+/* shall create a new process. The new process (child process) shall be an exact copy of the calling process*/
+int fork() 
+{
+	return syscall( SYS_FORK, 0, 0, 0, 0, 0, &errno );
+}
+
+/* shall create a new process. The new process (child process) shall be an exact copy of the calling process
+The vfork() function has the same effect as fork(), except that the behaviour is undefined if the process created by vfork() either modifies any data other than a variable of type pid_t used to store the return value from vfork(), or returns from the function in which vfork() was called, or calls any other function before successfully calling _exit() or one of the exec family of functions.
+*/
+int vfork() 
+{
+	return syscall( SYS_VFORK, 0, 0, 0, 0, 0, &errno );
+}
+
+/*send signal to a process*/
+int kill(int pid, int sig)
+{
+	return syscall( SYS_KILL, pid, sig, 0, 0, 0, &errno );
+}
+
+/*wait for child process to terminate and collect the status*/
+int wait(int *status)
+{
+	return syscall( SYS_WAITPID, (ulong)status, 0, 0, 0, 0 , &errno );
+}
+
+/*suspend the thread until a signal is received*/
+int pause(void)
+{
+	return syscall( SYS_PAUSE, 0, 0, 0, 0, 0 , &errno );
+}
+
+/*change the nice value of a process*/
+int nice(int incr)
+{
+	return syscall( SYS_WAITPID, incr, 0, 0, 0, 0 , &errno );
+}
+
+/*getenvironment*/
+char * getenvironment()
+{
+	return (char *)syscall( SYS_GETENVIRONMENT, 0, 0, 0, 0, 0, &errno );
+}
+
+/* get command line*/
+char * getcommandline()
+{
+	return (char *)syscall( SYS_GETCMDLINE, 0, 0, 0, 0, 0, &errno );
+}
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/statfs.c ../newlib-1.17.0/newlib/libc/sys/aceos/statfs.c
--- newlib-1.17.0/newlib/libc/sys/aceos/statfs.c	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/statfs.c	2009-05-23 08:06:20.375000000 +0530
@@ -0,0 +1,14 @@
+
+#include <sys/statfs.h>
+#include <syscall.h>
+
+int statfs (const char * path, struct statfs * buf)
+{
+	return (char *)syscall( SYS_STATFS, (ulong)path, (ulong)buf, 0, 0, 0, &errno );
+}
+
+int fstatfs (int fd, struct statfs *buf)
+{
+	return (char *)syscall( SYS_FSTATFS, (ulong)fd, (ulong)buf, 0, 0, 0, &errno );
+}
+
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/sys/_types.h ../newlib-1.17.0/newlib/libc/sys/aceos/sys/_types.h
--- newlib-1.17.0/newlib/libc/sys/aceos/sys/_types.h	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/sys/_types.h	2009-05-15 20:02:26.937500000 +0530
@@ -0,0 +1,54 @@
+/* ANSI C namespace clean utility typedefs */
+
+/* This file defines various typedefs needed by the system calls that support
+   the C library.  Basically, they're just the POSIX versions with an '_'
+   prepended.  This file lives in the `sys' directory so targets can provide
+   their own if desired (or they can put target dependant conditionals here).
+*/
+
+#ifndef	_SYS__TYPES_H
+#define _SYS__TYPES_H
+
+typedef long _off_t;
+__extension__ typedef long long _off64_t;
+
+typedef long _fpos_t;
+__extension__ typedef long long _fpos64_t;
+
+#if defined(__INT_MAX__) && __INT_MAX__ == 2147483647
+typedef int _ssize_t;
+#else
+typedef long _ssize_t;
+#endif
+
+#define __need_wint_t
+#include <stddef.h>
+
+/* Conversion state information.  */
+typedef struct
+{
+  int __count;
+  union
+  {
+    wint_t __wch;
+    unsigned char __wchb[4];
+  } __value;		/* Value so far.  */
+} _mbstate_t;
+
+struct __flock_mutex_t_tmp;
+typedef struct
+{
+  int __a;
+  int __b;
+  struct
+  {
+    long int __c1;
+    int __c2;
+  } __c;
+  int __d;
+  struct __flock_mutex_t_tmp * __e;
+} __flock_mutex_t;
+
+typedef struct { __flock_mutex_t mutex; } _flock_t;
+
+#endif	/* _SYS__TYPES_H */
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/sys/dirent.h ../newlib-1.17.0/newlib/libc/sys/aceos/sys/dirent.h
--- newlib-1.17.0/newlib/libc/sys/aceos/sys/dirent.h	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/sys/dirent.h	2009-05-15 20:02:26.953125000 +0530
@@ -0,0 +1,36 @@
+#ifndef _SYS_DIRENT_H
+# define _SYS_DIRENT_H
+
+/*
+ * This file was written to be compatible with the BSD directory
+ * routines, so it looks like it.  But it was written from scratch.
+ * Sean Eric Fagan, sef@Kithrup.COM
+ */
+
+typedef struct _dirdesc {
+	int		dd_fd;
+	long	dd_loc;
+	long	dd_size;
+	char	*dd_buf;
+	int		dd_len;
+	long	dd_seek;
+} DIR;
+
+# define __dirfd(dp)	((dp)->dd_fd)
+
+DIR *opendir (const char *);
+struct dirent *readdir (DIR *);
+void rewinddir (DIR *);
+int closedir (DIR *);
+
+#include <sys/types.h>
+
+struct dirent {
+	long	d_ino;
+	off_t	d_off;
+	unsigned short	d_reclen;
+	/* we need better syntax for variable-sized arrays */
+	char	d_name[1];
+};
+
+#endif
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/sys/ioctl.h ../newlib-1.17.0/newlib/libc/sys/aceos/sys/ioctl.h
--- newlib-1.17.0/newlib/libc/sys/aceos/sys/ioctl.h	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/sys/ioctl.h	2009-05-15 20:02:26.968750000 +0530
@@ -0,0 +1,12 @@
+#ifndef _SYS_IOCTL_H
+#define _SYS_IOCTL_H
+
+#define TCGETS		0
+#define TCSETS		1
+#define TCFLUSH		2
+#define	TCFLOW		3
+
+
+int ioctl(int fd, int request, ...);
+
+#endif
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/sys/mount.h ../newlib-1.17.0/newlib/libc/sys/aceos/sys/mount.h
--- newlib-1.17.0/newlib/libc/sys/aceos/sys/mount.h	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/sys/mount.h	2009-05-23 08:19:06.015625000 +0530
@@ -0,0 +1,32 @@
+#ifndef _SYS_MOUNT_H
+#define _SYS_MOUNT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/statfs.h>
+
+enum
+{
+  MOUNT_SYMLINK =       0x0001, /* "mount point" is a symlink */
+  MOUNT_BINARY =        0x0002, /* "binary" format read/writes */
+  MOUNT_SYSTEM =        0x0008, /* mount point came from system table */
+  MOUNT_EXEC   =        0x0010, /* Any file in the mounted directory gets 'x' bit */
+  MOUNT_MIXED   =       0x0080, /* reads are text, writes are binary not yet implemented */
+  MOUNT_NOTEXEC =       0x0100, /* don't check files for executable magic */
+  MOUNT_DEVFS =         0x0200, /* /device "filesystem" */
+  MOUNT_PROC =          0x0400, /* /proc "filesystem" */
+  MOUNT_ENC =           0x0800, /* encode special characters */
+  MOUNT_RO =            0x1000  /* read-only "filesystem" */
+};
+
+int mount (const char * fs, const char * path, unsigned flags);
+int umount (const char * path);
+int getmntinfo(struct statfs **mntbufp, int flags);
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/sys/poll.h ../newlib-1.17.0/newlib/libc/sys/aceos/sys/poll.h
--- newlib-1.17.0/newlib/libc/sys/aceos/sys/poll.h	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/sys/poll.h	2009-05-23 07:35:25.593750000 +0530
@@ -0,0 +1,30 @@
+#ifndef _SYS_POLL_H
+#define _SYS_POLL_H
+
+
+#define POLLIN  1       /* Set if data to read. */
+#define POLLPRI 2       /* Set if urgent data to read. */
+#define POLLOUT 4       /* Set if writing data wouldn't block. */
+#define POLLERR   8     /* An error occured. */
+#define POLLHUP  16     /* Shutdown or close happened. */
+#define POLLNVAL 32     /* Invalid file descriptor. */
+
+#define NPOLLFILE 64    /* Number of canonical fd's in one call to poll(). */
+
+/* The following values are defined by XPG4. */
+#define POLLRDNORM POLLIN
+#define POLLRDBAND POLLPRI
+#define POLLWRNORM POLLOUT
+#define POLLWRBAND POLLOUT
+
+struct pollfd {
+	int    fd;       /* file descriptor */
+	short  events;   /* events to look for */
+	short  revents;  /* events returned */
+};
+
+typedef unsigned int nfds_t;
+
+int poll(struct pollfd * fds, nfds_t nfds, int timeout);
+
+#endif
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/sys/stat.h ../newlib-1.17.0/newlib/libc/sys/aceos/sys/stat.h
--- newlib-1.17.0/newlib/libc/sys/aceos/sys/stat.h	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/sys/stat.h	2009-05-23 09:22:48.343750000 +0530
@@ -0,0 +1,82 @@
+#ifndef _SYS_STAT_H
+#define _SYS_STAT_H
+
+#include <unistd.h>
+#include <sys/types.h>
+
+struct stat
+{
+	dev_t     st_dev;		/*Device ID of device containing file. */
+	ino_t     st_ino;		/*File serial number. */
+	mode_t    st_mode;		/*Mode of file */
+	nlink_t   st_nlink;		/*Number of hard links to the file. */
+	uid_t     st_uid;		/*User ID of file. */
+	gid_t     st_gid;		/*Group ID of file. */
+	
+	dev_t     st_rdev;		/*Device ID (if file is character or block special). */
+
+	off_t     st_size;		/*For regular files, the file size in bytes.  
+							For symbolic links, the length in bytes of the pathname contained in the symbolic link.
+							For a shared memory object, the length in bytes. 
+							For a typed memory object, the length in bytes. 
+							For other file types, the use of this field is unspecified. */
+	time_t    st_atime;		/*Time of last access. */
+	time_t    st_mtime;		/*Time of last data modification. */
+	time_t    st_ctime;		/*Time of last status change. */
+	
+	blksize_t st_blksize;	/*A file system-specific preferred I/O block size for this object. In some file system types, this may vary from file to file.*/
+	blkcnt_t  st_blocks;	/*Number of blocks allocated for this object.*/
+};
+
+int chmod(const char *, mode_t);
+int fchmod(int, mode_t);
+int fstat(int, struct stat *);
+int lstat(const char *, struct stat *);
+int mkdir(const char *, mode_t);
+int mknod(const char *path, mode_t mode, dev_t dev);
+int stat(const char *, struct stat *);
+mode_t umask(mode_t);
+
+/* Traditional mask definitions for st_mode. */
+#define S_IFMT  0170000 /* type of file */
+#define S_IFLNK 0120000 /* symbolic link */
+#define S_IFREG 0100000 /* regular */
+#define S_IFBLK 0060000 /* block special */
+#define S_IFDIR 0040000 /* directory */
+#define S_IFCHR 0020000 /* character special */
+#define S_IFIFO 0010000 /* this is a FIFO */
+#define S_ISUID 0004000 /* set user id on execution */
+#define S_ISGID 0002000 /* set group id on execution */
+                                /* next is reserved for future use */
+#define S_ISVTX   01000         /* save swapped text even after use */
+
+/* POSIX masks for st_mode. */
+#define S_IRWXU   00700         /* owner:  rwx------ */
+#define S_IRUSR   00400         /* owner:  r-------- */
+#define S_IWUSR   00200         /* owner:  -w------- */
+#define S_IXUSR   00100         /* owner:  --x------ */
+
+#define S_IRWXG   00070         /* group:  ---rwx--- */
+#define S_IRGRP   00040         /* group:  ---r----- */
+#define S_IWGRP   00020         /* group:  ----w---- */
+#define S_IXGRP   00010         /* group:  -----x--- */
+
+#define S_IRWXO   00007         /* others: ------rwx */
+#define S_IROTH   00004         /* others: ------r-- */ 
+#define S_IWOTH   00002         /* others: -------w- */
+#define S_IXOTH   00001         /* others: --------x */
+
+/* Synonyms for above. */
+#define S_IEXEC         S_IXUSR
+#define S_IWRITE        S_IWUSR
+#define S_IREAD         S_IRUSR
+
+/* The following macros test st_mode (from POSIX Sec. 5.6.1.1). */
+#define S_ISREG(m)      (((m) & S_IFMT) == S_IFREG)     /* is a reg file */
+#define S_ISDIR(m)      (((m) & S_IFMT) == S_IFDIR)     /* is a directory */
+#define S_ISCHR(m)      (((m) & S_IFMT) == S_IFCHR)     /* is a char spec */
+#define S_ISBLK(m)      (((m) & S_IFMT) == S_IFBLK)     /* is a block spec */
+#define S_ISLNK(m)      (((m) & S_IFMT) == S_IFLNK)     /* is a symlink */
+#define S_ISFIFO(m)     (((m) & S_IFMT) == S_IFIFO)     /* is a pipe/FIFO */
+
+#endif
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/sys/statfs.h ../newlib-1.17.0/newlib/libc/sys/aceos/sys/statfs.h
--- newlib-1.17.0/newlib/libc/sys/aceos/sys/statfs.h	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/sys/statfs.h	2009-05-23 07:54:04.468750000 +0530
@@ -0,0 +1,29 @@
+#ifndef _SYS_STATFS_H_
+#define _SYS_STATFS_H_
+
+struct statfs {
+   long f_type;     /* type of filesystem */
+   long f_bsize;    /* optimal transfer block size */
+   long f_blocks;   /* total data blocks in file system */
+   long f_bfree;    /* free blocks in fs */
+   long f_bavail;   /* free blocks avail to non-superuser */
+   long f_files;    /* total file nodes in file system */
+   long f_ffree;    /* free file nodes in fs */
+   long f_fsid;     /* file system id */
+   long f_flag;		/* bit mask of f_flag values*/
+   long f_namemax;  /* maximum length of filenames */
+   long f_spare[6]; /* spare for later */
+};
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int statfs (const char *__path, struct statfs *__buf);
+int fstatfs (int __fd, struct statfs *__buf);
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/sys/termios.h ../newlib-1.17.0/newlib/libc/sys/aceos/sys/termios.h
--- newlib-1.17.0/newlib/libc/sys/aceos/sys/termios.h	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/sys/termios.h	2009-05-18 20:01:22.281250000 +0530
@@ -0,0 +1,142 @@
+#ifndef	_SYS_TERMIOS_H
+# define _SYS_TERMIOS_H
+
+# define _XCGETA (('x'<<8)|1)
+# define _XCSETA (('x'<<8)|2)
+# define _XCSETAW (('x'<<8)|3)
+# define _XCSETAF (('x'<<8)|4)
+# define _TCSBRK (('T'<<8)|5)
+# define _TCFLSH (('T'<<8)|7)
+# define _TCXONC (('T'<<8)|6)
+
+# define TCOOFF	0
+# define TCOON	1
+# define TCIOFF	2
+# define TCION	3
+
+# define TCIFLUSH	0
+# define TCOFLUSH	1
+# define TCIOFLUSH	2
+
+# define NCCS 13
+
+# define TCSAFLUSH	_XCSETAF
+# define TCSANOW	_XCSETA
+# define TCSADRAIN	_XCSETAW
+# define TCSADFLUSH	_XCSETAF
+
+# define IGNBRK	000001
+# define BRKINT	000002
+# define IGNPAR	000004
+# define INPCK	000020
+# define ISTRIP	000040
+# define INLCR	000100
+# define IGNCR	000200
+# define ICRNL	000400
+# define IXON	002000
+# define IXOFF	010000
+# define PARMRK	020000
+
+# define OPOST	000001
+# define OCRNL	000004
+# define ONLCR	000010
+# define ONOCR	000020
+# define TAB3	014000
+# define ONLRET ONLCR
+
+# define CLOCAL	004000
+# define CREAD	000200
+# define CSIZE	000060
+# define CS5	0
+# define CS6	020
+# define CS7	040
+# define CS8	060
+# define CSTOPB	000100
+# define HUPCL	002000
+# define PARENB	000400
+# define PARODD	001000
+
+# define ECHO	0000010
+# define ECHOE	0000020
+# define ECHOK	0000040
+# define ECHONL	0000100
+# define ICANON	0000002
+# define IEXTEN	0000400	/* anybody know *what* this does?! */
+# define ISIG	0000001
+# define NOFLSH	0000200
+# define TOSTOP	0001000
+
+# define VEOF	4	/* also VMIN -- thanks, AT&T */
+# define VEOL	5	/* also VTIME -- thanks again */
+# define VERASE	2
+# define VINTR	0
+# define VKILL	3
+# define VMIN	4	/* also VEOF */
+# define VQUIT	1
+# define VSUSP	10
+# define VTIME	5	/* also VEOL */
+# define VSTART	11
+# define VSTOP	12
+
+# define B0	000000
+# define B50	000001
+# define B75	000002
+# define B110	000003
+# define B134	000004
+# define B150	000005
+# define B200	000006
+# define B300	000007
+# define B600	000010
+# define B1200	000011
+# define B1800	000012
+# define B2400	000013
+# define B4800	000014
+# define B9600	000015
+# define B19200	000016
+# define B38400	000017
+
+typedef unsigned char cc_t;
+typedef unsigned short tcflag_t;
+typedef char speed_t;
+
+struct termios {
+	tcflag_t	c_iflag;
+	tcflag_t	c_oflag;
+	tcflag_t	c_cflag;
+	tcflag_t	c_lflag;
+	char		c_line;
+	cc_t		c_cc[NCCS];
+	speed_t		c_ispeed;
+	speed_t		c_ospeed;
+};
+
+# ifndef _NO_MACROS
+
+#  define cfgetospeed(tp)	((tp)->c_ospeed)
+#  define cfgetispeed(tp)	((tp)->c_ispeed)
+#  define cfsetospeed(tp,s)	(((tp)->c_ospeed = (s)), 0)
+#  define cfsetispeed(tp,s)	(((tp)->c_ispeed = (s)), 0)
+#  define tcdrain(fd)		ioctl (fd, _TCSBRK, 1)
+# endif	/* _NO_MACROS */
+
+#define termio termios
+
+#define cfgetospeed(tp)         ((tp)->c_ospeed)
+#define cfgetispeed(tp)         ((tp)->c_ispeed)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int tcgetattr (int, struct termios *);
+int tcsetattr (int, int, const struct termios *);
+int tcsendbreak (int, int);
+int tcflush (int, int);
+int tcflow (int, int);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _SYS_TERMIOS_H */
+
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/sys/types.h ../newlib-1.17.0/newlib/libc/sys/aceos/sys/types.h
--- newlib-1.17.0/newlib/libc/sys/aceos/sys/types.h	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/sys/types.h	2009-05-16 13:56:53.875000000 +0530
@@ -0,0 +1,174 @@
+/* libc/sys/linux/sys/types.h - The usual type zoo */
+
+/* Written 2000 by Werner Almesberger */
+
+/*-
+ * Copyright (c) 1982, 1986, 1991, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)types.h	8.6 (Berkeley) 2/19/95
+ * $FreeBSD: src/sys/sys/types.h,v 1.60 2002/04/10 15:58:13 mike Exp $
+ */
+
+#ifndef _SYS_TYPES_H
+#define _SYS_TYPES_H
+
+/* Newlib has it's own time_t and clock_t definitions in 
+ * libc/include/sys/types.h.  Repeat those here and
+ * skip the kernel's definitions. */
+
+#define __need_size_t
+#include <stddef.h>
+#include <sys/config.h>
+#include <machine/types.h>
+#include <sys/_types.h>
+#include <stdint.h>
+#include <stdlib.h>
+
+#if !defined(__time_t_defined) && !defined(_TIME_T)
+#define _TIME_T
+#define __time_t_defined
+typedef _TIME_T_ time_t;
+#endif
+
+#if !defined(__clock_t_defined) && !defined(_CLOCK_T)
+#define _CLOCK_T
+#define __clock_t_defined
+typedef _CLOCK_T_ clock_t;
+#endif
+
+#ifndef _SSIZE_T
+#define _SSIZE_T
+typedef _ssize_t ssize_t;
+#endif
+
+#ifndef __u_char_defined
+#ifdef __GNUC__
+__extension__ typedef long long quad_t;
+__extension__ typedef unsigned long long u_quad_t;
+#else
+typedef struct
+  {
+    long int __val[2];
+  } quad_t;
+typedef struct
+  {
+    unsigned long __val[2];
+  } u_quad_t;
+#endif
+typedef struct
+  {
+    int __val[2];
+  } fsid_t;
+#define __u_char_defined
+#endif
+
+typedef int clockid_t;
+
+#  define _SYS_TYPES_FD_SET
+#  define	NBBY	8		/* number of bits in a byte */
+/*
+ * Select uses bit masks of file descriptors in longs.
+ * These macros manipulate such bit fields (the filesystem macros use chars).
+ * FD_SETSIZE may be defined by the user, but the default here
+ * should be >= NOFILE (param.h).
+ */
+#  ifndef	FD_SETSIZE
+#	define	FD_SETSIZE	64
+#  endif
+
+typedef	long	fd_mask;
+#  define	NFDBITS	(sizeof (fd_mask) * NBBY)	/* bits per mask */
+#  ifndef	howmany
+#	define	howmany(x,y)	(((x)+((y)-1))/(y))
+#  endif
+
+typedef struct {
+        unsigned long fds_bits [(1024/(8 * sizeof(unsigned long)))];
+} __fd_set;
+
+typedef __fd_set fd_set;
+
+#  define	FD_SET(n, p)	((p)->fds_bits[(n)/NFDBITS] |= (1L << ((n) % NFDBITS)))
+#  define	FD_CLR(n, p)	((p)->fds_bits[(n)/NFDBITS] &= ~(1L << ((n) % NFDBITS)))
+#  define	FD_ISSET(n, p)	((p)->fds_bits[(n)/NFDBITS] & (1L << ((n) % NFDBITS)))
+#  define	FD_ZERO(p)	(__extension__ (void)({ \
+     size_t __i; \
+     char *__tmp = (char *)p; \
+     for (__i = 0; __i < sizeof (*(p)); ++__i) \
+       *__tmp++ = 0; \
+}))
+
+#define __mode_t_defined
+#define __gid_t_defined
+#define __uid_t_defined
+#define __pid_t_defined
+#define __ssize_t_defined
+#define __key_t_defined
+#define __off_t_defined
+#define __off64_t_defined
+
+typedef int dev_t;
+typedef int ino_t;
+typedef int mode_t;
+typedef int caddr_t;
+typedef long off_t;
+typedef int pid_t;
+typedef int uid_t;
+typedef int gid_t;
+typedef int key_t;
+typedef int nlink_t;
+typedef long suseconds_t;
+typedef long useconds_t;
+
+typedef long blksize_t;
+typedef long blkcnt_t;
+
+typedef unsigned char u_char;
+typedef unsigned short u_short;
+typedef unsigned int u_int;
+typedef unsigned long u_long;
+typedef unsigned char u_int8_t;
+typedef unsigned short u_int16_t;
+typedef unsigned long u_int32_t;
+typedef unsigned long long u_int64_t;
+
+typedef u_int32_t __uint32_t;
+typedef int32_t	__int32_t;
+typedef u_int16_t	__uint16_t;
+typedef int16_t	__int16_t;
+
+#endif
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/sys/unistd.h ../newlib-1.17.0/newlib/libc/sys/aceos/sys/unistd.h
--- newlib-1.17.0/newlib/libc/sys/aceos/sys/unistd.h	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/sys/unistd.h	2009-05-23 07:33:40.218750000 +0530
@@ -0,0 +1,250 @@
+#ifndef _SYS_UNISTD_H
+#define _SYS_UNISTD_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <_ansi.h>
+#include <sys/types.h>
+#include <sys/_types.h>
+#include <stddef.h>
+#include <sys/dirent.h>
+
+extern char **environ;
+
+int          access(const char *, int);
+unsigned int alarm(unsigned int);
+int          brk(void *);
+int          chdir(const char *);
+int          chroot(const char *);
+int          chown(const char *, uid_t, gid_t);
+int          close(int);
+size_t       confstr(int, char *, size_t);
+char        *crypt(const char *, const char *);
+char        *ctermid(char *);
+char        *cuserid(char *s); 
+int          dup(int);
+int          dup2(int, int);
+//void         encrypt(char[64], int);
+int          execl(const char *, const char *, ...);
+int          execle(const char *, const char *, ...);
+int          execlp(const char *, const char *, ...);
+int          execv(const char *, char *const []);
+int          execve(const char *, char *const [], char *const []);
+int          execvp(const char *, char *const []);
+void        _exit(int);
+int          fchown(int, uid_t, gid_t);
+int          fchdir(int);
+int          fdatasync(int);
+pid_t        fork(void);
+long int     fpathconf(int, int);
+int          fsync(int);
+int          ftruncate(int, off_t);
+char        *getcwd(char *, size_t);
+int          getdtablesize(void); 
+gid_t        getegid(void);
+uid_t        geteuid(void);
+gid_t        getgid(void);
+int          getgroups(int, gid_t []);
+int 		 gethostname(char *name, size_t namelen);
+long         gethostid(void);
+char        *getlogin(void);
+int          getlogin_r(char *, size_t);
+int          getopt(int, char * const [], const char *);
+int          getpagesize(void); 
+char        *getpass(const char *); 
+pid_t        getpgid(pid_t);
+pid_t        getpgrp(void);
+pid_t        getpid(void);
+pid_t        getppid(void);
+pid_t        getsid(pid_t);
+uid_t        getuid(void);
+char        *getwd(char *);
+int          isatty(int);
+int          lchown(const char *, uid_t, gid_t);
+int          link(const char *, const char *);
+int          lockf(int, int, off_t);
+off_t        lseek(int, off_t, int);
+int          nice(int);
+long int     pathconf(const char *, int);
+int          pause(void);
+int          pipe(int [2]);
+ssize_t      pread(int, void *, size_t, off_t);
+int          pthread_atfork(void (*)(void), void (*)(void),
+                 void(*)(void));
+ssize_t      pwrite(int, const void *, size_t, off_t);
+ssize_t      read(int, void *, size_t);
+int          readlink(const char *, char *, size_t);
+int          rmdir(const char *);
+void        *sbrk(intptr_t);
+int          setgid(gid_t);
+int          setpgid(pid_t, pid_t);
+pid_t        setpgrp(void);
+int          setregid(gid_t, gid_t);
+int          setreuid(uid_t, uid_t);
+pid_t        setsid(void);
+int          setuid(uid_t);
+unsigned int sleep(unsigned int);
+void         swab(const void *, void *, ssize_t);
+int          symlink(const char *, const char *);
+void         sync(void);
+long int     sysconf(int);
+pid_t        tcgetpgrp(int);
+int          tcsetpgrp(int, pid_t);
+int          truncate(const char *, off_t);
+char        *ttyname(int);
+int          ttyname_r(int, char *, size_t);
+useconds_t   ualarm(useconds_t, useconds_t);
+int          unlink(const char *);
+int          usleep(useconds_t);
+pid_t        vfork(void);
+ssize_t      write(int, const void *, size_t);
+
+extern char *optarg;			/* getopt(3) external variables */
+extern int optind, opterr, optopt;
+int	 getopt(int, char * const [], const char *);
+extern int optreset;			/* getopt(3) external variable */
+
+enum _SC_
+{
+	_SC_2_C_BIND,
+	_SC_2_C_DEV,
+	_SC_2_CHAR_TERM,
+	_SC_2_FORT_DEV,
+	_SC_2_FORT_RUN,
+	_SC_2_LOCALEDEF,
+	_SC_2_PBS,
+	_SC_2_PBS_ACCOUNTING,
+	_SC_2_PBS_CHECKPOINT,
+	_SC_2_PBS_LOCATE,
+	_SC_2_PBS_MESSAGE,
+	_SC_2_PBS_TRACK,
+	_SC_2_SW_DEV,
+	_SC_2_UPE,
+	_SC_2_VERSION,
+	_SC_ADVISORY_INFO,
+	_SC_AIO_LISTIO_MAX,
+	_SC_AIO_MAX,
+	_SC_AIO_PRIO_DELTA_MAX,
+	_SC_ARG_MAX,
+	_SC_ASYNCHRONOUS_IO,
+	_SC_ATEXIT_MAX,
+	_SC_BARRIERS,
+	_SC_BC_BASE_MAX,
+	_SC_BC_DIM_MAX,
+	_SC_BC_SCALE_MAX,
+	_SC_BC_STRING_MAX,
+	_SC_CHILD_MAX,
+	_SC_CLK_TCK,
+	_SC_CLOCK_SELECTION,
+	_SC_COLL_WEIGHTS_MAX,
+	_SC_CPUTIME,
+	_SC_DELAYTIMER_MAX,
+	_SC_EXPR_NEST_MAX,
+	_SC_FSYNC,
+	_SC_GETGR_R_SIZE_MAX,
+	_SC_GETPW_R_SIZE_MAX,
+	_SC_HOST_NAME_MAX,
+	_SC_IOV_MAX,
+	_SC_IPV6,
+	_SC_JOB_CONTROL,
+	_SC_LINE_MAX,
+	_SC_LOGIN_NAME_MAX,
+	_SC_MAPPED_FILES,
+	_SC_MEMLOCK,
+	_SC_MEMLOCK_RANGE,
+	_SC_MEMORY_PROTECTION,
+	_SC_MESSAGE_PASSING,
+	_SC_MONOTONIC_CLOCK,
+	_SC_MQ_OPEN_MAX,
+	_SC_MQ_PRIO_MAX,
+	_SC_NGROUPS_MAX,
+	_SC_OPEN_MAX,
+	_SC_PAGE_SIZE,
+	_SC_PAGESIZE,
+	_SC_PRIORITIZED_IO,
+	_SC_PRIORITY_SCHEDULING,
+	_SC_RAW_SOCKETS,
+	_SC_RE_DUP_MAX,
+	_SC_READER_WRITER_LOCKS,
+	_SC_REALTIME_SIGNALS,
+	_SC_REGEXP,
+	_SC_RTSIG_MAX,
+	_SC_SAVED_IDS,
+	_SC_SEM_NSEMS_MAX,
+	_SC_SEM_VALUE_MAX,
+	_SC_SEMAPHORES,
+	_SC_SHARED_MEMORY_OBJECTS,
+	_SC_SHELL,
+	_SC_SIGQUEUE_MAX,
+	_SC_SPAWN,
+	_SC_SPIN_LOCKS,
+	_SC_SPORADIC_SERVER,
+	_SC_SS_REPL_MAX,
+	_SC_STREAM_MAX,
+	_SC_SYMLOOP_MAX,
+	_SC_SYNCHRONIZED_IO,
+	_SC_THREAD_ATTR_STACKADDR,
+	_SC_THREAD_ATTR_STACKSIZE,
+	_SC_THREAD_CPUTIME,
+	_SC_THREAD_DESTRUCTOR_ITERATIONS,
+	_SC_THREAD_KEYS_MAX,
+	_SC_THREAD_PRIO_INHERIT,
+	_SC_THREAD_PRIO_PROTECT,
+	_SC_THREAD_PRIORITY_SCHEDULING,
+	_SC_THREAD_PROCESS_SHARED,
+	_SC_THREAD_SAFE_FUNCTIONS,
+	_SC_THREAD_SPORADIC_SERVER,
+	_SC_THREAD_STACK_MIN,
+	_SC_THREAD_THREADS_MAX,
+	_SC_THREADS,
+	_SC_TIMEOUTS,
+	_SC_TIMER_MAX,
+	_SC_TIMERS,
+	_SC_TRACE,
+	_SC_TRACE_EVENT_FILTER,
+	_SC_TRACE_EVENT_NAME_MAX,
+	_SC_TRACE_INHERIT,
+	_SC_TRACE_LOG,
+	_SC_TRACE_NAME_MAX,
+	_SC_TRACE_SYS_MAX,
+	_SC_TRACE_USER_EVENT_MAX,
+	_SC_TTY_NAME_MAX,
+	_SC_TYPED_MEMORY_OBJECTS,
+	_SC_TZNAME_MAX,
+	_SC_V6_ILP32_OFF32,
+	_SC_V6_ILP32_OFFBIG,
+	_SC_V6_LP64_OFF64,
+	_SC_V6_LPBIG_OFFBIG,
+	_SC_VERSION,
+	_SC_XOPEN_CRYPT,
+	_SC_XOPEN_ENH_I18N,
+	_SC_XOPEN_LEGACY,
+	_SC_XOPEN_REALTIME,
+	_SC_XOPEN_REALTIME_THREADS,
+	_SC_XOPEN_SHM,
+	_SC_XOPEN_STREAMS,
+	_SC_XOPEN_UNIX,
+	_SC_XOPEN_VERSION,
+};
+
+#define	F_OK	0
+#define	R_OK	4
+#define	W_OK	2
+#define	X_OK	1
+
+# define	SEEK_SET	0
+# define	SEEK_CUR	1
+# define	SEEK_END	2
+
+#define STDIN_FILENO    0       /* standard input file descriptor */
+#define STDOUT_FILENO   1       /* standard output file descriptor */
+#define STDERR_FILENO   2       /* standard error file descriptor */
+
+# define        MAXPATHLEN      1024
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _SYS_UNISTD_H */
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/sys/utsname.h ../newlib-1.17.0/newlib/libc/sys/aceos/sys/utsname.h
--- newlib-1.17.0/newlib/libc/sys/aceos/sys/utsname.h	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/sys/utsname.h	2009-05-15 20:02:27.062500000 +0530
@@ -0,0 +1,16 @@
+#ifndef _SYS_UTSNAME_H
+#define _SYS_UTSNAME_H
+
+#define UTS_MAX_NAME	50		
+
+struct utsname {
+    char sysname[UTS_MAX_NAME];			/*! name of this implementation of the operating system*/
+    char nodename[UTS_MAX_NAME];		/*! name of this node within an implementation-dependent communications network*/
+    char release[UTS_MAX_NAME];			/*! current release level of this implementation*/
+    char version[UTS_MAX_NAME];			/*! current version level of this release*/
+    char machine[UTS_MAX_NAME];			/*! name of the hardware type on which the system is running*/
+};
+
+int uname(struct utsname *name);
+
+#endif
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/syscall.h ../newlib-1.17.0/newlib/libc/sys/aceos/syscall.h
--- newlib-1.17.0/newlib/libc/sys/aceos/syscall.h	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/syscall.h	2009-05-23 09:25:09.859375000 +0530
@@ -0,0 +1,187 @@
+#ifndef _SYSCALL_H
+#define _SYSCALL_H
+
+#undef errno
+extern int errno;
+
+typedef unsigned long ulong;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*system call numbers*/
+enum sys_call_numbers
+{
+	SYS_EXIT=0,
+	SYS_FORK,
+	SYS_VFORK,
+	SYS_WAITPID,
+	SYS_EXECVE,
+	SYS_PAUSE,
+	SYS_NICE,
+	SYS_KILL,
+	SYS_WAIT4,
+	SYS_GETCMDLINE,
+	SYS_GETENVIRONMENT,
+		
+	SYS_SIGNAL,
+	SYS_SIGACTION,
+	SYS_SIGSUSPEND,
+	SYS_SIGPENDING,
+	SYS_SGETMASK,
+	SYS_SSETMASK,
+	SYS_SIGALTSTACK,
+
+	SYS_OPEN,
+	SYS_CLOSE,
+	SYS_READ,
+	SYS_WRITE,
+	SYS_LINK,
+	SYS_UNLINK,
+	SYS_CHDIR,
+	SYS_GETCWD,
+	SYS_MKNOD,
+	SYS_CHMOD,
+	SYS_FCHMOD,
+	SYS_STAT,
+	SYS_LSTAT,
+	SYS_LSEEK,
+	SYS_FSTAT,
+	SYS_SYNC,
+	SYS_RENAME,
+	SYS_MKDIR,
+	SYS_RMDIR,
+	SYS_FCHDIR,
+	SYS_SELECT,
+	SYS_POLL,
+	SYS_DUP,
+	SYS_DUP2,
+	SYS_PIPE,
+	SYS_IOCTL,
+	SYS_FCNTL,
+	SYS_OPEN_DIR,
+	SYS_CLOSE_DIR,
+	SYS_READ_DIR,
+	SYS_READ_DIR_R,
+	SYS_REWIND_DIR,
+	SYS_SEEK_DIR,
+	SYS_TELL_DIR,
+	SYS_TRUNCATE,
+	SYS_FTRUNCATE,
+	
+	SYS_MOUNT,
+	SYS_UMOUNT,
+	SYS_GETMNTINFO,
+	SYS_STATFS,
+	SYS_FSTATFS,
+	
+	SYS_UMASK,	
+	
+	SYS_MADVISE,
+	SYS_MUNMAP,
+	SYS_MREMAP,
+	SYS_MMAP2,
+	SYS_MPROTECT,
+	SYS_FLOCK,
+	SYS_MSYNC,
+	SYS_SYSCTL,
+	SYS_MLOCK,
+	SYS_MUNLOCK,
+	SYS_MLOCKALL,
+	SYS_MUNLOCKALL,		
+	SYS_BRK,
+	SYS_GET_MEMPOLICY,
+	SYS_SET_MEMPOLICY,
+	SYS_ALLOCATE_VIRTUAL_MEMORY,
+		
+	SYS_TIME,
+	SYS_STIME,
+	SYS_UTIMES,
+	SYS_PTRACE,
+	SYS_ALARM,	
+	SYS_UTIME,
+	SYS_ACCESS,	
+	SYS_TIMES,
+	SYS_GETRUSAGE,
+	SYS_GETTIMEOFDAY,
+	SYS_SETTIMEOFDAY,
+	SYS_CLOCK_SETTIME,
+	SYS_CLOCK_GETTIME,
+	SYS_CLOCK_GETRES,
+	SYS_CLOCK_NANOSLEEP,
+	SYS_TIMER_CREATE,
+	SYS_TIMER_SETTIME,
+	SYS_TIMER_GETTIME,
+	SYS_TIMER_GETOVERRUN,
+	SYS_TIMER_DELETE,
+	SYS_SETITIMER,
+	SYS_GETITIMER,
+	SYS_NANOSLEEP,
+	SYS_SLEEP,
+	
+	SYS_SETHOSTNAME,
+	SYS_SYS_CONF,
+	SYS_GETRLIMIT,
+	SYS_SETRLIMIT,
+	SYS_SYMLINK,
+	
+	SYS_SCHED_SETAFFINITY,
+	SYS_SCHED_GETAFFINITY,
+	SYS_SCHED_SETPARAM,
+	SYS_SCHED_GETPARAM,
+	SYS_SCHED_SETSCHEDULER,
+	SYS_SCHED_GETSCHEDULER,
+	SYS_SCHED_YIELD,
+	SYS_SCHED_GET_PRIORITY_MAX,
+	SYS_SCHED_GET_PRIORITY_MIN,
+	SYS_SCHED_RR_GET_INTERVAL,
+	SYS_RT_SIGRETURN,
+	SYS_RT_SIGACTION,
+	SYS_RT_SIGPROCMASK,
+	SYS_RT_SIGPENDING,
+	SYS_RT_SIGTIMEDWAIT,
+	SYS_RT_SIGQUEUEINFO,
+	SYS_RT_SIGSUSPEND,
+	SYS_SIGRETURN,
+	SYS_SIGPROCMASK,	
+	
+	SYS_SWAPON,
+	SYS_SWAPOFF,
+	
+	SYS_REBOOT,
+	SYS_SOCKETCALL,
+	
+	SYS_UNAME,
+	SYS_GETHOSTID,
+	SYS_GETLOGIN,
+	SYS_GETLOGIN_R,
+	SYS_GETUID,
+	SYS_GETEUID,
+	SYS_GETGID,
+	SYS_GETEGID,
+	SYS_GETPGID,
+	SYS_GETPGRP,
+	SYS_GETPID,
+	SYS_GETPPID,
+	SYS_GETSID,
+	SYS_GETPWUID,
+	SYS_SETUID,
+	SYS_SETGID,
+	SYS_SETPGID,
+	SYS_SETPGRP,
+	SYS_SETREGID,
+	SYS_SETREUID,
+	SYS_SETSID,
+	
+	SYS_TTYNAME,
+	SYS_ISATTY,
+};
+
+unsigned long inline syscall(int syscall_number, ulong arg1, ulong arg2, ulong arg3, ulong arg4, ulong arg5, int * error_number);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif 
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/syscalls.c ../newlib-1.17.0/newlib/libc/sys/aceos/syscalls.c
--- newlib-1.17.0/newlib/libc/sys/aceos/syscalls.c	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/syscalls.c	2009-05-17 18:48:48.609375000 +0530
@@ -0,0 +1,28 @@
+#include <syscall.h>
+
+/*trap into kernel*/
+unsigned long inline syscall(int syscall_number, ulong arg1, ulong arg2, ulong arg3, ulong arg4, ulong arg5, int * error_number)
+{
+	unsigned long return_value=0, error_no = 0;
+	
+	asm volatile("	movl %2, %%eax; \
+					movl %3, %%ebx; \
+					movl %4, %%ecx; \
+					movl %5, %%edx; \
+					movl %6, %%esi; \
+					movl %7, %%edi; \
+					int $0x80; 		\
+					mov %%eax, %0; 	\
+					mov %%ebx, %1	\
+				"
+                : "=m"(return_value), "=m"(error_no)
+                : "m"(syscall_number), "m"(arg1), "m"(arg2), "m"(arg3), "m"(arg4), "m"(arg5)
+                : "%eax", "%ebx", "%ecx", "%edx", "%esi", "%edi"
+				);
+				
+	/*if the caller is interested in error number set it*/
+	if ( error_number )
+		* error_number = error_no;
+	
+	return return_value;
+}
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/sysconf.c ../newlib-1.17.0/newlib/libc/sys/aceos/sysconf.c
--- newlib-1.17.0/newlib/libc/sys/aceos/sysconf.c	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/sysconf.c	2009-05-15 20:02:27.109375000 +0530
@@ -0,0 +1,12 @@
+#include <unistd.h>
+#include <limits.h>
+#include <time.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <syscall.h>
+
+/*provides a method for the application to determine the current value of a configurable system limit or option*/
+long int sysconf (int name)
+{
+	return syscall( SYS_SYS_CONF, (ulong)name, 0, 0, 0, 0, &errno );
+}
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/termios.c ../newlib-1.17.0/newlib/libc/sys/aceos/termios.c
--- newlib-1.17.0/newlib/libc/sys/aceos/termios.c	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/termios.c	2009-05-18 19:44:00.359375000 +0530
@@ -0,0 +1,28 @@
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/termios.h>
+#include <sys/ioctl.h>
+
+/*! get the parameters associated with the terminal*/
+int tcgetattr(int fd, struct termios *termios_p)
+{
+	return ioctl(fd, TCGETS, termios_p);
+}
+
+/*!  set the parameters associated with the terminal */
+int tcsetattr(int fd, int cmd, const struct termios *termios_p)
+{
+	return ioctl(fd, cmd, termios_p);
+}
+
+/*! suspend or restart the transmission or reception of data*/
+int tcflow (int fd, int action)
+{
+	return ioctl (fd, TCFLOW, action);
+}
+
+/*! flush non-transmitted output data, non-read input data or both*/
+int tcflush (int fd, int queue_selector)
+{
+	return ioctl (fd, TCFLUSH, queue_selector);
+}
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/tty.c ../newlib-1.17.0/newlib/libc/sys/aceos/tty.c
--- newlib-1.17.0/newlib/libc/sys/aceos/tty.c	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/tty.c	2009-05-18 20:23:56.703125000 +0530
@@ -0,0 +1,17 @@
+#include <stdio.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <syscall.h>
+#include <sys/unistd.h>
+
+/*! find the pathname of a terminal*/
+char *ttyname(int fildes)
+{
+	return (char *)syscall( SYS_TTYNAME, (ulong)fildes, 0, 0, 0, 0, &errno );
+}
+
+/*! test for a terminal device*/
+int isatty(int file)
+{
+	return syscall( SYS_ISATTY, (ulong)file, 0, 0, 0, 0, &errno );
+}
diff -rupN newlib-1.17.0/newlib/libc/sys/aceos/uname.c ../newlib-1.17.0/newlib/libc/sys/aceos/uname.c
--- newlib-1.17.0/newlib/libc/sys/aceos/uname.c	1970-01-01 05:30:00.000000000 +0530
+++ ../newlib-1.17.0/newlib/libc/sys/aceos/uname.c	2009-05-18 20:17:59.125000000 +0530
@@ -0,0 +1,176 @@
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/utsname.h>
+#include <syscall.h>
+
+/*! get the name of the current system*/
+int uname(struct utsname * utsname)
+{
+	return syscall( SYS_UNAME, (ulong)utsname, 0, 0, 0, 0, &errno );
+}
+
+/*! get an identifier for the current host*/
+long gethostid()
+{
+	return syscall( SYS_GETHOSTID, 0, 0, 0, 0, 0, &errno );
+}
+
+/*! et name of current host*/
+int gethostname (char *name, size_t len)
+{
+	struct utsname nodebuf;
+	size_t nodelen;
+
+	if (uname (&nodebuf))
+		return -1;
+
+	nodelen = strlen (nodebuf.nodename) + 1;
+	if (len < nodelen)
+		memcpy (name, nodebuf.nodename, len);
+	else
+		memcpy (name, nodebuf.nodename, nodelen);
+
+	if (nodelen > len)
+	{
+		errno = ENAMETOOLONG;
+		return -1;
+	}
+	return 0;
+}
+
+/*!  get login name*/
+char * getlogin()
+{
+	return (char *)syscall( SYS_GETLOGIN, 0, 0, 0, 0, 0, &errno );
+}
+
+int getlogin_r(char * name, size_t size)
+{
+	return syscall( SYS_GETLOGIN_R, (ulong)name, (ulong)size, 0, 0, 0, &errno );
+}
+
+/*! get a real user ID*/
+uid_t getuid()
+{
+	return syscall( SYS_GETUID, 0, 0, 0, 0, 0, &errno );
+}
+
+/*! get group id*/
+gid_t getgid()
+{
+	return syscall( SYS_GETGID, 0, 0, 0, 0, 0, &errno );
+}
+
+/*! get effective group id*/
+uid_t geteuid(void)
+{
+	return syscall( SYS_GETEUID, 0, 0, 0, 0, 0, &errno );
+}
+
+/*get the effective group ID*/
+gid_t getegid()
+{
+	return syscall( SYS_GETEGID, 0, 0, 0, 0, 0, &errno );
+}
+
+/*! get process group ID */
+pid_t getpgid(pid_t pid)
+{
+	return syscall( SYS_GETPGID, 0, 0, 0, 0, 0, &errno );
+}
+
+/*! get the process group ID of the calling process*/
+pid_t getpgrp()
+{
+	return syscall( SYS_GETPGRP, 0, 0, 0, 0, 0, &errno );
+}
+
+/*! get current process id*/
+pid_t getpid()
+{
+	return syscall( SYS_GETPID, 0, 0, 0, 0, 0, &errno );
+}
+
+/*! get parent process id*/
+pid_t getppid()
+{
+	return syscall( SYS_GETPPID, 0, 0, 0, 0, 0, &errno );
+}
+
+/*! get the process group ID of a session leader*/
+pid_t getsid(pid_t pid)
+{
+	return syscall( SYS_GETSID, pid, 0, 0, 0, 0, &errno );
+}
+
+/*! earch user database for a user ID*/
+struct passwd *getpwuid(uid_t uid)
+{
+	return (struct passwd *)syscall( SYS_GETPWUID, (ulong)uid, 0, 0, 0, 0, &errno );
+}
+
+/*! set user ID*/
+int setuid(uid_t uid)
+{
+	return syscall( SYS_SETUID, (ulong)uid, 0, 0, 0, 0, &errno );
+}
+/*! set group ID*/
+int setgid(gid_t gid)
+{
+	return syscall( SYS_SETGID, (ulong)gid, 0, 0, 0, 0, &errno );
+}
+
+/*! set process group ID for job control*/
+int setpgid(pid_t pid1, pid_t pid2)
+{
+	return syscall( SYS_SETPGID, (ulong)pid1, (ulong)pid2, 0, 0, 0, &errno );
+}
+
+/*!set the process group ID*/
+pid_t setpgrp(void)
+{
+	return syscall( SYS_SETPGRP, 0, 0, 0, 0, 0, &errno );
+}
+
+/*!  set real and effective group IDs*/
+int setregid(gid_t gid1, gid_t gid2)
+{
+	return syscall( SYS_SETREGID, (ulong)gid1, (ulong)gid2, 0, 0, 0, &errno );
+}
+
+/*! et real and effective user IDs */
+int setreuid(uid_t uid1, uid_t uid2)
+{
+	return syscall( SYS_SETREUID, (ulong)uid1, (ulong)uid2, 0, 0, 0, &errno );
+}
+
+/*! create session and set process group ID */
+pid_t setsid(void)
+{
+	return syscall( SYS_SETSID, 0, 0, 0, 0, 0, &errno );
+}
+
+void endpwent(void)
+{
+	return;
+}
+void setpwent(void)
+{
+	return;
+}
+
+void endgrent(void)
+{
+	return;
+}
+
+struct group *getgrent(void)
+{
+	return NULL;
+}
+
+void setgrent(void)
+{
+	return;
+}
